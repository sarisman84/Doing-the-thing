using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Cinemachine;
using Extensions;
using Extensions.InputExtension;
using Interactivity;
using Interactivity.Pickup;
using Player.Weapons;
using UnityEngine;
using UnityEngine.InputSystem;
using Utility;

namespace Player
{
    public class FirstPersonController : MonoBehaviour
    {
        //These InputActionReferences are generated by Unity's new Input System. Using references allows the possibility of swapping different profiles of input.
        public InputActionReference movementInput, jumpInput, lookInput, crouchInput, sprintInput;
        public InputActionReference aimSightsInput, primaryFireInput, secondaryFireInput, weaponSelectInput;

        //Controller information

        #region Controller Variables

        //Movement
        [Space] public float movementSpeed;
        public float sprintMultiplier;
        public float crouchMultiplier;

        //Camera sensitivity
        [Range(50, 300f)] public float sensitivity = 200f;
        public float jumpForce;

        //Collision sizes and checks for the Ground and Stand methods.
        public Vector3 groundCheckSize = Vector3.one;
        public Vector3 sealingCheckSize = Vector3.one;
        public LayerMask movementCheckLayer;

        //Public reference to a Cinemachine Camera that is used for the player.
        public CinemachineFreeLook playerCamera;

        //FOV information for both normal and sprint modes.
        [Range(10f, 100f)] public float fieldOfView = 60f;
        [Range(10f, 100f)] public float fieldOfViewWhileSprinting = 90f;

        //Pickup information
        [Space] public LayerMask pickupMask;
        public float currencyPickupRange = 20;
        public int currentCurrency = 0;

        //Local references to components and custom classes. 
        //Local variables that store information such as speed or input.
        private Rigidbody _physics;
        private CapsuleCollider _collisionBody;
        public FPCameraHandler fpcHandler;
        private CurrencyHandler _currencyHandler;
        public WeaponController weaponController;
        private Vector2 _inputVector;
        private float _totalSpeed;
        private float _standingHeight;
        private Vector3 _trueInputVector;
        private Vector2 _lookValue;

        private float _originalFOV;
        private float _sprintFOV;
        private bool _isSprinting;
        private bool _isJumping;
        private bool _isCrouching;

        #endregion


        public bool CameraLocked { get; set; }
        public event Action ONUpdateCallback;

        private Vector3 BottonPositionOfCollider
        {
            get
            {
                var position = transform.position;
                return new Vector3(position.x, position.y - (_collisionBody.bounds.size.y / 2f), position.z);
            }
        }

        private Vector3 TopPositionOfCollider
        {
            get
            {
                var position = transform.position;
                return new Vector3(position.x, position.y + (_collisionBody.bounds.size.y / 2f), position.z);
            }
        }

        private void Awake()
        {
            _currencyHandler = new CurrencyHandler(this);

            //Assigns the player as a priority target for any enemy.
            EnemyBehaivourManager.Access.AssignTarget(transform);

            //Init
            _collisionBody = GetComponent<CapsuleCollider>();
            _physics = GetComponent<Rigidbody>();
            fpcHandler = new FPCameraHandler();

            //Saving values for FOV and Sprint FOV respectively.
            _originalFOV = fieldOfView;
            _sprintFOV = fieldOfViewWhileSprinting;

            //Applies FOV to the camera's lens.
            playerCamera.m_Lens.FieldOfView = _originalFOV;

            //Init for the Input System. Enables all of the references assigned in the argument.
            InputExtension.SetActiveAll(false, movementInput, sprintInput, jumpInput, crouchInput, lookInput,
                aimSightsInput, primaryFireInput, secondaryFireInput);

            //Init for the weapon managing class that handles the selection and firing of the current weapon.
            weaponController = new WeaponController(aimSightsInput, primaryFireInput, secondaryFireInput,
                weaponSelectInput, this);
        }


        private void Update()
        {
            //Get values from Input References
            _inputVector = movementInput.GetInputValue<Vector2>();
            _lookValue = lookInput.GetInputValue<Vector2>();
            _isSprinting = sprintInput.GetInputValue<bool>();
            _isJumping = jumpInput.GetInputValue<bool>();
            _isCrouching = crouchInput.GetInputValue<bool>();

            //Calculate input values to reflect strafing in correlation to player direction.
            //Calculate and alter final speed values depending on whenever or not the player is using x input.
            _trueInputVector = transform.right * _inputVector.x + transform.forward * _inputVector.y;
            _totalSpeed = _isSprinting && !_isCrouching && CanStand() ? movementSpeed * sprintMultiplier :
                _isCrouching || !CanStand() ? movementSpeed * crouchMultiplier : movementSpeed;

            //Calculate and alter cameraFOV depending on player's input.
            float currentFOV = playerCamera.m_Lens.FieldOfView;
            currentFOV = _isSprinting && !_isCrouching && CanStand()
                ? Mathf.Lerp(currentFOV, _sprintFOV, 0.25f)
                : Mathf.Lerp(currentFOV, _originalFOV, 0.25f);
            playerCamera.m_Lens.FieldOfView = currentFOV;

            if (!CameraLocked)
                //Call method that handles player rotation on mouse input.
                fpcHandler.RotatePlayerHorizontally(transform, _lookValue, sensitivity);

            //Call method that alters collision's size depending on whenever or not player is crouching.
            OnCrouchAlterPlayerHeight(_isCrouching);


            ONUpdateCallback?.Invoke();


            currentCurrency = _currencyHandler.Currency;
        }

        /// <summary>
        /// Changes the camera's position as well as the collision heights to make the player able to crouch.
        /// </summary>
        /// <param name="isCrouching">Input check</param>
        private void OnCrouchAlterPlayerHeight(bool isCrouching)
        {
            var position = transform.position;
            if (isCrouching)
            {
                _standingHeight = position.y;
                _collisionBody.height = 1f;
                _collisionBody.center = new Vector3(0, -0.5f, 0);
                playerCamera.m_Orbits[1].m_Height = -0.5f;

                return;
            }

            if (CanStand())
            {
                _collisionBody.center = Vector3.zero;
                playerCamera.m_Orbits[1].m_Height = 0;
                _collisionBody.height = 2f;
            }
        }

        /// <summary>
        /// Checks whenever the player can stand by using an OverlapBox above the player's head.
        /// </summary>
        /// <returns>Returns true if there is no object detected above the player's head.</returns>
        private bool CanStand()
        {
            List<Collider> foundObjects = Physics
                .OverlapBox(TopPositionOfCollider, sealingCheckSize, transform.rotation, movementCheckLayer).ToList();
            return foundObjects.FindAll(c => c != this._collisionBody).Count == 0;
        }

        private void FixedUpdate()
        {
            var velocity = _physics.velocity;
            velocity = new Vector3(_trueInputVector.x * _totalSpeed, velocity.y, _trueInputVector.z * _totalSpeed);
            _physics.velocity = velocity;

            PickupEntities(currencyPickupRange, pickupMask);

            if (_isJumping && IsGrounded() && !_isCrouching)
                _physics.AddForce(Vector3.up * (jumpForce * 10), ForceMode.VelocityChange);
        }

        /// <summary>
        /// Detects nearby pickups by using an OverlapSphere. When detected, objects will get disabled and their corresponding type of pickup will be called.
        /// </summary>
        /// <param name="pickupRange">The range in which objects will be detected and ultimately picked up.</param>
        /// <param name="pickupMask">A filter in which the OverlapSphere will only attempt to detect objects from.</param>
        private void PickupEntities(float pickupRange, LayerMask pickupMask)
        {
            Collider[] foundObjs = Physics.OverlapSphere(transform.position, pickupRange, pickupMask);

            if (foundObjs.Equals(null)) return;
            foreach (var t in foundObjs)
            {
                BasePickup weapon = t.GetComponent<BasePickup>();
                if (weapon)
                {
                    if (!weapon.OnPickup(this))
                        continue;
                }
                else
                {
                    _currencyHandler.Earn(1);
                }

                t.gameObject.SetActive(false);
            }
        }

        /// <summary>
        /// Checks if there are any gameObjects bellow the player's feet.
        /// </summary>
        /// <returns>Returns true if there is at least one gameObject bellow the player's feet.</returns>
        private bool IsGrounded()
        {
            List<Collider> foundObjects = Physics.OverlapBox(BottonPositionOfCollider, groundCheckSize,
                transform.rotation, movementCheckLayer).ToList();
            return foundObjects.FindAll(c => c != _collisionBody).Count != 0;
        }


        private void OnDrawGizmos()
        {
            if (!Application.isPlaying) return;
            Gizmos.color = Color.red;
            if (IsGrounded()) Gizmos.color = Color.green;
            Gizmos.DrawCube(BottonPositionOfCollider, groundCheckSize * 2f);

            Gizmos.color = Color.red;
            if (!CanStand()) Gizmos.color = Color.green;
            Gizmos.DrawCube(TopPositionOfCollider, sealingCheckSize * 2f);
        }


        private void LateUpdate()
        {
            if (!CameraLocked)
                fpcHandler.RotateCameraVertically(playerCamera.transform, _lookValue, sensitivity);
        }


        private void OnDisable()
        {
            //In case this gameObject is disabled, it is required to disable the input references with it as to avoid any input errors.
            SetActiveLocalInput(false);
            RemoveListenersFromEventManager();
        }


        private void OnEnable()
        {
            //In case this gameObject is enabled, the references assigned to the gameObject will be enabled with the gameObject so that the player can regain control of this gameObject.
            SetActiveLocalInput(true);
            AddListenersToEventManager();
        }

        private void AddListenersToEventManager()
        {
            // EventManager.ListenTo("Player_EnableCursor", () => SetCameraAndCursorActive(true));
            // EventManager.ListenTo("Player_DisableCursor", () => SetCameraAndCursorActive(false));
            // EventManager.ListenTo("PlayerFall_DetachFromPlayer",
            //     () => Health.SetCameraBehaivour(playerCamera, transform, Health.CameraBehaivour.Look));
            // EventManager.ListenTo("PlayerFall_FollowPlayer",
            //     () => Health.SetCameraBehaivour(playerCamera, transform, Health.CameraBehaivour.Follow));
            // EventManager.ListenTo("PlayerFall_LookAtPlayer",
            //     () => Health.RotateCameraTowards(playerCamera, transform));
            EventManager.ListenTo(SetCursorActiveEvent, (value) => SetCameraAndCursorActive((bool) value));
            EventManager.ListenTo(CameraFallBehaivourEvent,
                (value) => Health.SetCameraBehaivour(playerCamera, transform, (Health.CameraBehaivour) value));
            EventManager.ListenTo(ConstantlyLookTowardsThePlayerEvent,
                (value) => Health.RotateCameraTowards(playerCamera, transform));
            EventManager.ListenTo(SetInputActiveEvent, o =>
            {
                SetActiveLocalInput((bool) o);
                return null;
            });

            EventManager.ListenTo(MoveEntityEvent, o => MovePlayer((Vector3) o));
        }

        public const string CameraFallBehaivourEvent = "Player_SetFallingBehaivour";
        public const string SetCursorActiveEvent = "Player_SetCursorActive";
        public const string SetInputActiveEvent = "Player_SetInputActive";
        public const string ConstantlyLookTowardsThePlayerEvent = "PlayerFall_LookAtPlayer";
        public const string MoveEntityEvent = "Player_MoveEntity";

        private void RemoveListenersFromEventManager()
        {
            EventManager.StopListeningTo(SetCursorActiveEvent, (value) => SetCameraAndCursorActive((bool) value));
            EventManager.StopListeningTo(SetInputActiveEvent, o =>
            {
                SetActiveLocalInput((bool) o);
                return null;
            });
            EventManager.StopListeningTo(CameraFallBehaivourEvent,
                (value) => Health.SetCameraBehaivour(playerCamera, transform, (Health.CameraBehaivour) value));
            EventManager.StopListeningTo(ConstantlyLookTowardsThePlayerEvent,
                (value) => Health.RotateCameraTowards(playerCamera, transform));
            EventManager.StopListeningTo(MoveEntityEvent, o => MovePlayer((Vector3) o));
        }

        private object SetCameraAndCursorActive(bool value)
        {
            CameraLocked = value;
            fpcHandler.AlterCursorState(value);
            // SetActiveLocalInput(!value);
            return null;
        }

        private object MovePlayer(Vector3 velocity)
        {
            _physics.MovePosition(transform.position + velocity);
            return _physics.velocity;
        }


        /// <summary>
        /// Alters the active state of all the input references.
        /// </summary>
        /// <param name="value">The state in which all the input reference will be in.</param>
        private void SetActiveLocalInput(bool value)
        {
            InputExtension.SetActiveAll(value, movementInput, sprintInput, jumpInput, crouchInput, lookInput,
                aimSightsInput, primaryFireInput, secondaryFireInput, weaponSelectInput);
        }
    }
}